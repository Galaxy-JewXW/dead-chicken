# 智能危险树木标记改进说明

## 功能概述

根据用户需求，对"随机标记危险"功能进行了智能化改进，现在系统会优先选择离电塔近且比较高的树木进行标记，而不是完全随机选择。

## 主要改进

### 1. 减少标记数量
- **原来：** 随机选择5-15%的树木作为危险树木
- **现在：** 选择1-3%的树木作为危险树木
- **效果：** 大幅减少标记数量，避免界面过于混乱

### 2. 智能选择策略
- **距离优先：** 优先选择距离电塔较近的树木
- **高度优先：** 优先选择高度较高的树木
- **综合评分：** 结合距离和高度计算危险评分

### 3. 危险等级智能分配
- **高评分（>150）：** 标记为"紧急"危险等级
- **中等评分（100-150）：** 标记为"危险"等级
- **低评分（<100）：** 标记为"警告"等级

## 技术实现

### 1. 电塔检测
```csharp
var powerTowers = FindObjectsOfType<GameObject>().Where(obj => 
    obj.name.ToLower().Contains("tower") || 
    obj.name.ToLower().Contains("电塔") ||
    obj.name.ToLower().Contains("pole") ||
    obj.name.ToLower().Contains("杆")).ToArray();
```

### 2. 危险评分计算
```csharp
// 距离评分：距离越近分数越高
float distanceScore = minDistance > 0 ? 100f / minDistance : 100f;

// 高度评分：高度越高分数越高
float heightScore = treeHeight * 10f;

// 综合评分
score = distanceScore + heightScore;
```

### 3. 树木高度计算
```csharp
float CalculateTreeHeight(GameObject tree)
{
    // 优先使用Renderer的bounds
    var renderer = tree.GetComponent<Renderer>();
    if (renderer != null)
    {
        return renderer.bounds.size.y;
    }
    
    // 备用方案：使用Collider
    var collider = tree.GetComponent<Collider>();
    if (collider != null)
    {
        return collider.bounds.size.y;
    }
    
    // 最后方案：使用Transform scale估算
    return tree.transform.localScale.y * 2f;
}
```

## 用户体验改进

### 1. 更精准的标记
- 不再随机标记，而是基于实际危险因素
- 标记的树木更符合实际风险评估需求

### 2. 更少的干扰
- 标记数量大幅减少，界面更清晰
- 重点突出真正危险的树木

### 3. 更智能的等级分配
- 危险等级与实际情况相符
- 高危险树木更容易识别

## 使用效果

### 标记前
- 随机选择大量树木
- 危险等级分配不合理
- 界面信息过多

### 标记后
- 智能选择少量关键树木
- 危险等级基于实际评分
- 界面简洁明了

## 兼容性说明

### 1. 电塔检测
- 支持多种电塔命名方式
- 如果没有找到电塔，会使用到原点的距离作为参考

### 2. 高度计算
- 多种高度计算方法，确保兼容性
- 从精确到估算的降级策略

### 3. 向后兼容
- 保持原有的标记功能
- 只是改进了选择策略

## 总结

通过这次改进，危险树木标记功能变得更加智能和实用。系统现在能够：
1. 减少不必要的标记，提高界面清晰度
2. 优先标记真正危险的树木（高且近电塔）
3. 根据实际情况分配合理的危险等级
4. 提供更好的用户体验和更准确的风险评估
